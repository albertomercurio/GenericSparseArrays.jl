var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"This page contains the complete API documentation for GenericSparseArrays.jl.\n\n","category":"section"},{"location":"api/#Types","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"api/#Functions","page":"API Reference","title":"Functions","text":"","category":"section"},{"location":"api/#GenericSparseArrays.AbstractGenericSparseArray","page":"API Reference","title":"GenericSparseArrays.AbstractGenericSparseArray","text":"AbstractGenericSparseArray{Tv,Ti,N} <: AbstractSparseArray{Tv,Ti,N}\n\nSupertype for sparse arrays that can have their underlying storage on various devices (CPU, GPU, accelerators). This package keeps the hierarchy backend-agnostic; dispatch is expected to leverage the concrete types of internal buffers (e.g. Vector, CuArray, etc.) rather than an explicit backend flag.\n\n\n\n\n\n","category":"type"},{"location":"api/#GenericSparseArrays.GenericSparseVector","page":"API Reference","title":"GenericSparseArrays.GenericSparseVector","text":"GenericSparseVector{Tv,Ti,IndT<:AbstractVector{Ti},ValT<:AbstractVector{Tv}} <: AbstractGenericSparseVector{Tv,Ti}\n\nSparse vector with generic index and value storage containers which may reside on different devices. The logical length is stored along with index/value buffers.\n\nFields\n\nn::Ti          - logical length of the vector\nnzind::IndT    - indices of stored (typically nonzero) entries (1-based)\nnzval::ValT    - stored values\n\nConstructors validate that the index and value vectors have matching length.\n\n\n\n\n\n","category":"type"},{"location":"api/#GenericSparseArrays.GenericSparseMatrixCSC","page":"API Reference","title":"GenericSparseArrays.GenericSparseMatrixCSC","text":"GenericSparseMatrixCSC{Tv,Ti,ColPtrT,RowValT,NzValT} <: AbstractGenericSparseMatrix{Tv,Ti}\n\nCompressed Sparse Column (CSC) matrix with generic storage vectors for column pointer, row indices, and nonzero values. Buffer types (e.g. Vector, GPU array types) enable dispatch on device characteristics.\n\nFields\n\nm::Int               - number of rows\nn::Int               - number of columns\ncolptr::ColPtrT      - column pointer array (length n+1)\nrowval::RowValT      - row indices of stored entries\nnzval::NzValT        - stored values\n\n\n\n\n\n","category":"type"},{"location":"api/#GenericSparseArrays.GenericSparseMatrixCSR","page":"API Reference","title":"GenericSparseArrays.GenericSparseMatrixCSR","text":"GenericSparseMatrixCSR{Tv,Ti,RowPtrT,ColValT,NzValT} <: AbstractGenericSparseMatrix{Tv,Ti}\n\nCompressed Sparse Row (CSR) matrix with generic storage vectors for row pointer, column indices, and nonzero values. Buffer types (e.g. Vector, GPU array types) enable dispatch on device characteristics.\n\nFields\n\nm::Int               - number of rows\nn::Int               - number of columns\nrowptr::RowPtrT      - row pointer array (length m+1)\ncolval::ColValT      - column indices of stored entries\nnzval::NzValT        - stored values\n\n\n\n\n\n","category":"type"},{"location":"api/#GenericSparseArrays.GenericSparseMatrixCOO","page":"API Reference","title":"GenericSparseArrays.GenericSparseMatrixCOO","text":"GenericSparseMatrixCOO{Tv,Ti,RowIndT<:AbstractVector{Ti},ColIndT<:AbstractVector{Ti},NzValT<:AbstractVector{Tv}} <: AbstractGenericSparseMatrix{Tv,Ti}\n\nCoordinate (COO) sparse matrix with generic storage vectors for row indices, column indices, and nonzero values. Buffer types (e.g. Vector, GPU array types) enable dispatch on device characteristics.\n\nFields\n\nm::Int               - number of rows\nn::Int               - number of columns\nrowind::RowIndT      - row indices of stored entries\ncolind::ColIndT      - column indices of stored entries\nnzval::NzValT        - stored values\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.:*-Tuple{GenericSparseMatrixCOO, GenericSparseMatrixCOO}","page":"API Reference","title":"Base.:*","text":"*(A::GenericSparseMatrixCOO, B::GenericSparseMatrixCOO)\n\nMultiply two sparse matrices in COO format. Both matrices must have compatible dimensions (number of columns of A equals number of rows of B) and be on the same backend (device).\n\nThe multiplication converts to CSC format, performs the multiplication with GPU-compatible kernels, and converts back to COO format. This approach is used for all cases including transpose/adjoint since COO doesn't have an efficient direct multiplication algorithm.\n\nExamples\n\njulia> using GenericSparseArrays, SparseArrays\n\njulia> A = GenericSparseMatrixCOO(sparse([1, 2], [1, 2], [2.0, 3.0], 2, 2));\n\njulia> B = GenericSparseMatrixCOO(sparse([1, 2], [1, 2], [4.0, 5.0], 2, 2));\n\njulia> C = A * B;\n\njulia> collect(C)\n2×2 Matrix{Float64}:\n 8.0   0.0\n 0.0  15.0\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:*-Tuple{GenericSparseMatrixCSC, GenericSparseMatrixCSC}","page":"API Reference","title":"Base.:*","text":"*(A::GenericSparseMatrixCSC, B::GenericSparseMatrixCSC)\n\nMultiply two sparse matrices in CSC format. Both matrices must have compatible dimensions (number of columns of A equals number of rows of B) and be on the same backend (device).\n\nThe multiplication uses GPU-compatible kernels for efficient sparse-sparse matrix multiplication (SpGEMM).\n\nExamples\n\njulia> using GenericSparseArrays, SparseArrays\n\njulia> A = GenericSparseMatrixCSC(sparse([1, 2], [1, 2], [2.0, 3.0], 2, 2));\n\njulia> B = GenericSparseMatrixCSC(sparse([1, 2], [1, 2], [4.0, 5.0], 2, 2));\n\njulia> C = A * B;\n\njulia> collect(C)\n2×2 Matrix{Float64}:\n 8.0   0.0\n 0.0  15.0\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:*-Tuple{GenericSparseMatrixCSR, GenericSparseMatrixCSR}","page":"API Reference","title":"Base.:*","text":"*(A::GenericSparseMatrixCSR, B::GenericSparseMatrixCSR)\n\nMultiply two sparse matrices in CSR format. Both matrices must have compatible dimensions (number of columns of A equals number of rows of B) and be on the same backend (device).\n\nThe multiplication uses GPU-compatible kernels for efficient sparse-sparse matrix multiplication (SpGEMM).\n\nExamples\n\njulia> using GenericSparseArrays, SparseArrays\n\njulia> A = GenericSparseMatrixCSR(GenericSparseMatrixCOO(sparse([1, 2], [1, 2], [2.0, 3.0], 2, 2)));\n\njulia> B = GenericSparseMatrixCSR(GenericSparseMatrixCOO(sparse([1, 2], [1, 2], [4.0, 5.0], 2, 2)));\n\njulia> C = A * B;\n\njulia> collect(C)\n2×2 Matrix{Float64}:\n 8.0   0.0\n 0.0  15.0\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:+-Tuple{GenericSparseMatrixCOO, GenericSparseMatrixCOO}","page":"API Reference","title":"Base.:+","text":"+(A::GenericSparseMatrixCOO, B::GenericSparseMatrixCOO)\n\nAdd two sparse matrices in COO format. Both matrices must have the same dimensions and be on the same backend (device).\n\nThe result is a COO matrix with entries from both A and B properly merged, with duplicate entries (same row and column) combined by summing their values.\n\nExamples\n\njulia> using GenericSparseArrays, SparseArrays\n\njulia> A = GenericSparseMatrixCOO(sparse([1, 2], [1, 2], [1.0, 2.0], 2, 2));\n\njulia> B = GenericSparseMatrixCOO(sparse([1, 2], [2, 1], [3.0, 4.0], 2, 2));\n\njulia> C = A + B;\n\njulia> collect(C)\n2×2 Matrix{Float64}:\n 1.0  3.0\n 4.0  2.0\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:+-Tuple{GenericSparseMatrixCSC, GenericSparseMatrixCSC}","page":"API Reference","title":"Base.:+","text":"+(A::GenericSparseMatrixCSC, B::GenericSparseMatrixCSC)\n\nAdd two sparse matrices in CSC format. Both matrices must have the same dimensions and be on the same backend (device).\n\nExamples\n\njulia> using GenericSparseArrays, SparseArrays\n\njulia> A = GenericSparseMatrixCSC(sparse([1, 2], [1, 2], [1.0, 2.0], 2, 2));\n\njulia> B = GenericSparseMatrixCSC(sparse([1, 2], [2, 1], [3.0, 4.0], 2, 2));\n\njulia> C = A + B;\n\njulia> collect(C)\n2×2 Matrix{Float64}:\n 1.0  3.0\n 4.0  2.0\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:+-Tuple{GenericSparseMatrixCSR, GenericSparseMatrixCSR}","page":"API Reference","title":"Base.:+","text":"+(A::GenericSparseMatrixCSR, B::GenericSparseMatrixCSR)\n\nAdd two sparse matrices in CSR format. Both matrices must have the same dimensions and be on the same backend (device).\n\nExamples\n\njulia> using GenericSparseArrays, SparseArrays\n\njulia> A = GenericSparseMatrixCSR(sparse([1, 2], [1, 2], [1.0, 2.0], 2, 2));\n\njulia> B = GenericSparseMatrixCSR(sparse([1, 2], [2, 1], [3.0, 4.0], 2, 2));\n\njulia> C = A + B;\n\njulia> collect(C)\n2×2 Matrix{Float64}:\n 1.0  3.0\n 4.0  2.0\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.kron-Tuple{GenericSparseMatrixCSC, GenericSparseMatrixCSC}","page":"API Reference","title":"Base.kron","text":"kron(A::GenericSparseMatrixCSC, B::GenericSparseMatrixCSC)\n\nCompute the Kronecker product of two sparse matrices in CSC format.\n\nThe Kronecker product is computed by converting to COO format, computing the  product, and converting back to CSC format.\n\nExamples\n\njulia> using GenericSparseArrays, SparseArrays\n\njulia> A = GenericSparseMatrixCSC(sparse([1, 2], [1, 2], [1.0, 2.0], 2, 2));\n\njulia> B = GenericSparseMatrixCSC(sparse([1, 2], [1, 2], [3.0, 4.0], 2, 2));\n\njulia> C = kron(A, B);\n\njulia> size(C)\n(4, 4)\n\njulia> nnz(C)\n4\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.kron-Tuple{GenericSparseMatrixCSR, GenericSparseMatrixCSR}","page":"API Reference","title":"Base.kron","text":"kron(A::GenericSparseMatrixCSR, B::GenericSparseMatrixCSR)\n\nCompute the Kronecker product of two sparse matrices in CSR format.\n\nThe Kronecker product is computed by converting to COO format, computing the  product, and converting back to CSR format.\n\nExamples\n\njulia> using GenericSparseArrays, SparseArrays\n\njulia> A_coo = GenericSparseMatrixCOO(sparse([1, 2], [1, 2], [1.0, 2.0], 2, 2));\n\njulia> B_coo = GenericSparseMatrixCOO(sparse([1, 2], [1, 2], [3.0, 4.0], 2, 2));\n\njulia> A = GenericSparseMatrixCSR(A_coo);\n\njulia> B = GenericSparseMatrixCSR(B_coo);\n\njulia> C = kron(A, B);\n\njulia> size(C)\n(4, 4)\n\njulia> nnz(C)\n4\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.kron-Union{Tuple{Ti2}, Tuple{Tv2}, Tuple{Ti1}, Tuple{Tv1}, Tuple{GenericSparseMatrixCOO{Tv1, Ti1, RowIndT, ColIndT, NzValT} where {RowIndT<:AbstractVector{Ti1}, ColIndT<:AbstractVector{Ti1}, NzValT<:AbstractVector{Tv1}}, GenericSparseMatrixCOO{Tv2, Ti2, RowIndT, ColIndT, NzValT} where {RowIndT<:AbstractVector{Ti2}, ColIndT<:AbstractVector{Ti2}, NzValT<:AbstractVector{Tv2}}}} where {Tv1, Ti1, Tv2, Ti2}","page":"API Reference","title":"Base.kron","text":"kron(A::GenericSparseMatrixCOO, B::GenericSparseMatrixCOO)\n\nCompute the Kronecker product of two sparse matrices in COO format.\n\nThe Kronecker product of two matrices A (size m×n) and B (size p×q)  is an (mp)×(nq) matrix formed by multiplying each element of A by the  entire matrix B.\n\nExamples\n\njulia> using GenericSparseArrays, SparseArrays\n\njulia> A = GenericSparseMatrixCOO(sparse([1, 2], [1, 2], [1.0, 2.0], 2, 2));\n\njulia> B = GenericSparseMatrixCOO(sparse([1, 2], [1, 2], [3.0, 4.0], 2, 2));\n\njulia> C = kron(A, B);\n\njulia> size(C)\n(4, 4)\n\njulia> nnz(C)\n4\n\n\n\n\n\n","category":"method"},{"location":"#GenericSparseArrays","page":"Home","title":"GenericSparseArrays","text":"Documentation for GenericSparseArrays.","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"GenericSparseArrays provides backend-agnostic sparse array container types whose internal storage vectors may live on different devices (CPU / accelerators). The initial implementation supplies:\n\nGenericSparseVector – sparse vector with generic index & value buffers.\nGenericSparseMatrixCSC – Compressed Sparse Column matrix with parametric column pointer, row index, and nonzero value buffers.\nGenericSparseMatrixCSR – Compressed Sparse Row matrix with parametric row pointer, column index, and nonzero value buffers.\n\nThese types mirror the Base SparseVector / SparseMatrixCSC interfaces for introspection (size, length, nonzeros, etc.) and can roundtrip convert to and from the Base representations.","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"#Basic-Usage","page":"Home","title":"Basic Usage","text":"using GenericSparseArrays, SparseArrays\n\n# Create a sparse vector\nV = sparsevec([2,5], [1.0, 3.5], 6)\ndV = GenericSparseVector(V)  # construct backend-agnostic version on the CPU\n\n@show size(dV)\n@show SparseVector(dV) == V\n\n# Create a sparse matrix\nA = sparse([1,2,1],[1,1,2],[2.0,3.0,4.0], 2, 2)\ndA = GenericSparseMatrixCSC(A)\n\n@show size(dA)\n@show SparseMatrixCSC(dA) == A","category":"section"},{"location":"#Matrix-Vector-Multiplication","page":"Home","title":"Matrix-Vector Multiplication","text":"# Create a sparse matrix\nA_sparse = sparse([1,2,1,3],[1,1,2,3],[2.0,3.0,4.0,5.0], 3, 3)\n@show A_sparse\n\n# Convert to GenericSparseMatrixCSC\nA_device = GenericSparseMatrixCSC(A_sparse)\n\n# Create a vector\nb = [1.0, 2.0, 3.0]\n\n# Matrix-vector multiplication\nc = A_device * b\n@show c\n\n# Verify result matches standard sparse matrix\n@show A_sparse * b == c","category":"section"},{"location":"#Backend-Adaptation-with-JLArrays","page":"Home","title":"Backend Adaptation with JLArrays","text":"JLArrays.jl provides a CPU fallback backend for testing and CI purposes. Here we use it to demonstrate backend adaptation with Adapt.jl.\n\nusing JLArrays\nusing Adapt: adapt\n\n# Create a sparse matrix\nA_sparse = sprand(Float64, 5, 4, 0.6)\n\n# Convert to GenericSparseMatrixCSC\nA_device = GenericSparseMatrixCSC(A_sparse)\n\n# Adapt to JLArray backend (CPU fallback for CI)\nA_jl = adapt(JLArray, A_device)\n\n# Create vector on same backend\nb = rand(Float64, 4)\nb_jl = JLArray(b)\n\n# Matrix-vector multiplication on JLArray backend\nc_jl = A_jl * b_jl\n\n# Results should match\n@show collect(c_jl) ≈ A_sparse * b","category":"section"},{"location":"#CSR-Matrix-Format","page":"Home","title":"CSR Matrix Format","text":"GenericSparseArrays.jl also supports the Compressed Sparse Row (CSR) format via the GenericSparseMatrixCSR type. It can be used similarly to the CSC format. \n\n# Create a sparse matrix\nA_sparse = sparse([1,2,1,3],[1,1,2,3],[2.0,3.0,4.0,5.0], 3, 3)\n\n# Convert to CSR format\nA_csr = GenericSparseMatrixCSR(A_sparse)\n@show size(A_csr)\n\n# Convert back to standard sparse matrix\n@show SparseMatrixCSC(A_csr) == A_sparse\n\n# Matrix-vector multiplication with CSR\nb = [1.0, 2.0, 3.0]\nc = A_csr * b\n@show c","category":"section"},{"location":"#Future-Work","page":"Home","title":"Future Work","text":"Planned extensions include COO formats, sparse-dense and sparse-sparse linear algebra kernels leveraging KernelAbstractions.jl / AcceleratedKernels.jl, and device-specific adaptations via dispatch on the internal buffer types.","category":"section"},{"location":"#See-Also","page":"Home","title":"See Also","text":"API Reference for complete function documentation","category":"section"}]
}
