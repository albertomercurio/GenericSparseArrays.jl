var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"This page contains the complete API documentation for DeviceSparseArrays.jl.\n\n","category":"section"},{"location":"api/#Types","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"api/#Functions","page":"API Reference","title":"Functions","text":"","category":"section"},{"location":"api/#DeviceSparseArrays.AbstractDeviceSparseArray","page":"API Reference","title":"DeviceSparseArrays.AbstractDeviceSparseArray","text":"AbstractDeviceSparseArray{Tv,Ti,N} <: AbstractSparseArray{Tv,Ti,N}\n\nSupertype for sparse arrays that can have their underlying storage on various devices (CPU, GPU, accelerators). This package keeps the hierarchy backend-agnostic; dispatch is expected to leverage the concrete types of internal buffers (e.g. Vector, CuArray, etc.) rather than an explicit backend flag.\n\n\n\n\n\n","category":"type"},{"location":"api/#DeviceSparseArrays.DeviceSparseVector","page":"API Reference","title":"DeviceSparseArrays.DeviceSparseVector","text":"DeviceSparseVector{Tv,Ti,IndT<:AbstractVector{Ti},ValT<:AbstractVector{Tv}} <: AbstractDeviceSparseVector{Tv,Ti}\n\nSparse vector with generic index and value storage containers which may reside on different devices. The logical length is stored along with index/value buffers.\n\nFields\n\nn::Ti          - logical length of the vector\nnzind::IndT    - indices of stored (typically nonzero) entries (1-based)\nnzval::ValT    - stored values\n\nConstructors validate that the index and value vectors have matching length.\n\n\n\n\n\n","category":"type"},{"location":"api/#DeviceSparseArrays.DeviceSparseMatrixCSC","page":"API Reference","title":"DeviceSparseArrays.DeviceSparseMatrixCSC","text":"DeviceSparseMatrixCSC{Tv,Ti,ColPtrT,RowValT,NzValT} <: AbstractDeviceSparseMatrix{Tv,Ti}\n\nCompressed Sparse Column (CSC) matrix with generic storage vectors for column pointer, row indices, and nonzero values. Buffer types (e.g. Vector, GPU array types) enable dispatch on device characteristics.\n\nFields\n\nm::Int               - number of rows\nn::Int               - number of columns\ncolptr::ColPtrT      - column pointer array (length n+1)\nrowval::RowValT      - row indices of stored entries\nnzval::NzValT        - stored values\n\n\n\n\n\n","category":"type"},{"location":"api/#DeviceSparseArrays.DeviceSparseMatrixCSR","page":"API Reference","title":"DeviceSparseArrays.DeviceSparseMatrixCSR","text":"DeviceSparseMatrixCSR{Tv,Ti,RowPtrT,ColValT,NzValT} <: AbstractDeviceSparseMatrix{Tv,Ti}\n\nCompressed Sparse Row (CSR) matrix with generic storage vectors for row pointer, column indices, and nonzero values. Buffer types (e.g. Vector, GPU array types) enable dispatch on device characteristics.\n\nFields\n\nm::Int               - number of rows\nn::Int               - number of columns\nrowptr::RowPtrT      - row pointer array (length m+1)\ncolval::ColValT      - column indices of stored entries\nnzval::NzValT        - stored values\n\n\n\n\n\n","category":"type"},{"location":"api/#DeviceSparseArrays.DeviceSparseMatrixCOO","page":"API Reference","title":"DeviceSparseArrays.DeviceSparseMatrixCOO","text":"DeviceSparseMatrixCOO{Tv,Ti,RowIndT<:AbstractVector{Ti},ColIndT<:AbstractVector{Ti},NzValT<:AbstractVector{Tv}} <: AbstractDeviceSparseMatrix{Tv,Ti}\n\nCoordinate (COO) sparse matrix with generic storage vectors for row indices, column indices, and nonzero values. Buffer types (e.g. Vector, GPU array types) enable dispatch on device characteristics.\n\nFields\n\nm::Int               - number of rows\nn::Int               - number of columns\nrowind::RowIndT      - row indices of stored entries\ncolind::ColIndT      - column indices of stored entries\nnzval::NzValT        - stored values\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.kron-Tuple{DeviceSparseMatrixCSC, DeviceSparseMatrixCSC}","page":"API Reference","title":"Base.kron","text":"kron(A::DeviceSparseMatrixCSC, B::DeviceSparseMatrixCSC)\n\nCompute the Kronecker product of two sparse matrices in CSC format.\n\nThe Kronecker product is computed by converting to COO format, computing the  product, and converting back to CSC format.\n\nExamples\n\njulia> using DeviceSparseArrays, SparseArrays\n\njulia> A = DeviceSparseMatrixCSC(sparse([1, 2], [1, 2], [1.0, 2.0], 2, 2));\n\njulia> B = DeviceSparseMatrixCSC(sparse([1, 2], [1, 2], [3.0, 4.0], 2, 2));\n\njulia> C = kron(A, B);\n\njulia> size(C)\n(4, 4)\n\njulia> nnz(C)\n4\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.kron-Tuple{DeviceSparseMatrixCSR, DeviceSparseMatrixCSR}","page":"API Reference","title":"Base.kron","text":"kron(A::DeviceSparseMatrixCSR, B::DeviceSparseMatrixCSR)\n\nCompute the Kronecker product of two sparse matrices in CSR format.\n\nThe Kronecker product is computed by converting to COO format, computing the  product, and converting back to CSR format.\n\nExamples\n\njulia> using DeviceSparseArrays, SparseArrays\n\njulia> A_coo = DeviceSparseMatrixCOO(sparse([1, 2], [1, 2], [1.0, 2.0], 2, 2));\n\njulia> B_coo = DeviceSparseMatrixCOO(sparse([1, 2], [1, 2], [3.0, 4.0], 2, 2));\n\njulia> A = DeviceSparseMatrixCSR(A_coo);\n\njulia> B = DeviceSparseMatrixCSR(B_coo);\n\njulia> C = kron(A, B);\n\njulia> size(C)\n(4, 4)\n\njulia> nnz(C)\n4\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.kron-Union{Tuple{Ti2}, Tuple{Tv2}, Tuple{Ti1}, Tuple{Tv1}, Tuple{DeviceSparseMatrixCOO{Tv1, Ti1, RowIndT, ColIndT, NzValT} where {RowIndT<:AbstractVector{Ti1}, ColIndT<:AbstractVector{Ti1}, NzValT<:AbstractVector{Tv1}}, DeviceSparseMatrixCOO{Tv2, Ti2, RowIndT, ColIndT, NzValT} where {RowIndT<:AbstractVector{Ti2}, ColIndT<:AbstractVector{Ti2}, NzValT<:AbstractVector{Tv2}}}} where {Tv1, Ti1, Tv2, Ti2}","page":"API Reference","title":"Base.kron","text":"kron(A::DeviceSparseMatrixCOO, B::DeviceSparseMatrixCOO)\n\nCompute the Kronecker product of two sparse matrices in COO format.\n\nThe Kronecker product of two matrices A (size m×n) and B (size p×q)  is an (mp)×(nq) matrix formed by multiplying each element of A by the  entire matrix B.\n\nExamples\n\njulia> using DeviceSparseArrays, SparseArrays\n\njulia> A = DeviceSparseMatrixCOO(sparse([1, 2], [1, 2], [1.0, 2.0], 2, 2));\n\njulia> B = DeviceSparseMatrixCOO(sparse([1, 2], [1, 2], [3.0, 4.0], 2, 2));\n\njulia> C = kron(A, B);\n\njulia> size(C)\n(4, 4)\n\njulia> nnz(C)\n4\n\n\n\n\n\n","category":"method"},{"location":"#DeviceSparseArrays","page":"Home","title":"DeviceSparseArrays","text":"Documentation for DeviceSparseArrays.","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"DeviceSparseArrays provides backend-agnostic sparse array container types whose internal storage vectors may live on different devices (CPU / accelerators). The initial implementation supplies:\n\nDeviceSparseVector – sparse vector with generic index & value buffers.\nDeviceSparseMatrixCSC – Compressed Sparse Column matrix with parametric column pointer, row index, and nonzero value buffers.\nDeviceSparseMatrixCSR – Compressed Sparse Row matrix with parametric row pointer, column index, and nonzero value buffers.\n\nThese types mirror the Base SparseVector / SparseMatrixCSC interfaces for introspection (size, length, nonzeros, etc.) and can roundtrip convert to and from the Base representations.","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"#Basic-Usage","page":"Home","title":"Basic Usage","text":"using DeviceSparseArrays, SparseArrays\n\n# Create a sparse vector\nV = sparsevec([2,5], [1.0, 3.5], 6)\ndV = DeviceSparseVector(V)  # construct backend-agnostic version on the CPU\n\n@show size(dV)\n@show SparseVector(dV) == V\n\n# Create a sparse matrix\nA = sparse([1,2,1],[1,1,2],[2.0,3.0,4.0], 2, 2)\ndA = DeviceSparseMatrixCSC(A)\n\n@show size(dA)\n@show SparseMatrixCSC(dA) == A","category":"section"},{"location":"#Matrix-Vector-Multiplication","page":"Home","title":"Matrix-Vector Multiplication","text":"# Create a sparse matrix\nA_sparse = sparse([1,2,1,3],[1,1,2,3],[2.0,3.0,4.0,5.0], 3, 3)\n@show A_sparse\n\n# Convert to DeviceSparseMatrixCSC\nA_device = DeviceSparseMatrixCSC(A_sparse)\n\n# Create a vector\nb = [1.0, 2.0, 3.0]\n\n# Matrix-vector multiplication\nc = A_device * b\n@show c\n\n# Verify result matches standard sparse matrix\n@show A_sparse * b == c","category":"section"},{"location":"#Backend-Adaptation-with-JLArrays","page":"Home","title":"Backend Adaptation with JLArrays","text":"JLArrays.jl provides a CPU fallback backend for testing and CI purposes. Here we use it to demonstrate backend adaptation with Adapt.jl.\n\nusing JLArrays\nusing Adapt: adapt\n\n# Create a sparse matrix\nA_sparse = sprand(Float64, 5, 4, 0.6)\n\n# Convert to DeviceSparseMatrixCSC\nA_device = DeviceSparseMatrixCSC(A_sparse)\n\n# Adapt to JLArray backend (CPU fallback for CI)\nA_jl = adapt(JLArray, A_device)\n\n# Create vector on same backend\nb = rand(Float64, 4)\nb_jl = JLArray(b)\n\n# Matrix-vector multiplication on JLArray backend\nc_jl = A_jl * b_jl\n\n# Results should match\n@show collect(c_jl) ≈ A_sparse * b","category":"section"},{"location":"#CSR-Matrix-Format","page":"Home","title":"CSR Matrix Format","text":"DeviceSparseArrays.jl also supports the Compressed Sparse Row (CSR) format via the DeviceSparseMatrixCSR type. It can be used similarly to the CSC format. \n\n# Create a sparse matrix\nA_sparse = sparse([1,2,1,3],[1,1,2,3],[2.0,3.0,4.0,5.0], 3, 3)\n\n# Convert to CSR format\nA_csr = DeviceSparseMatrixCSR(A_sparse)\n@show size(A_csr)\n\n# Convert back to standard sparse matrix\n@show SparseMatrixCSC(A_csr) == A_sparse\n\n# Matrix-vector multiplication with CSR\nb = [1.0, 2.0, 3.0]\nc = A_csr * b\n@show c","category":"section"},{"location":"#Future-Work","page":"Home","title":"Future Work","text":"Planned extensions include COO formats, sparse-dense and sparse-sparse linear algebra kernels leveraging KernelAbstractions.jl / AcceleratedKernels.jl, and device-specific adaptations via dispatch on the internal buffer types.","category":"section"},{"location":"#See-Also","page":"Home","title":"See Also","text":"API Reference for complete function documentation","category":"section"}]
}
