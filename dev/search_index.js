var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"This page contains the complete API documentation for GenericSparseArrays.jl.\n\n","category":"section"},{"location":"api/#Types","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"api/#Functions","page":"API Reference","title":"Functions","text":"","category":"section"},{"location":"api/#GenericSparseArrays.AbstractGenericSparseArray","page":"API Reference","title":"GenericSparseArrays.AbstractGenericSparseArray","text":"AbstractGenericSparseArray{Tv,Ti,N} <: AbstractSparseArray{Tv,Ti,N}\n\nSupertype for sparse arrays that can have their underlying storage on various devices (CPU, GPU, accelerators). This package keeps the hierarchy backend-agnostic; dispatch is expected to leverage the concrete types of internal buffers (e.g. Vector, CuArray, etc.) rather than an explicit backend flag.\n\n\n\n\n\n","category":"type"},{"location":"api/#GenericSparseArrays.GenericSparseVector","page":"API Reference","title":"GenericSparseArrays.GenericSparseVector","text":"GenericSparseVector{Tv,Ti,IndT<:AbstractVector{Ti},ValT<:AbstractVector{Tv}} <: AbstractGenericSparseVector{Tv,Ti}\n\nSparse vector with generic index and value storage containers which may reside on different devices. The logical length is stored along with index/value buffers.\n\nFields\n\nn::Ti          - logical length of the vector\nnzind::IndT    - indices of stored (typically nonzero) entries (1-based)\nnzval::ValT    - stored values\n\nConstructors validate that the index and value vectors have matching length.\n\n\n\n\n\n","category":"type"},{"location":"api/#GenericSparseArrays.GenericSparseMatrixCSC","page":"API Reference","title":"GenericSparseArrays.GenericSparseMatrixCSC","text":"GenericSparseMatrixCSC{Tv,Ti,ColPtrT,RowValT,NzValT} <: AbstractGenericSparseMatrix{Tv,Ti}\n\nCompressed Sparse Column (CSC) matrix with generic storage vectors for column pointer, row indices, and nonzero values. Buffer types (e.g. Vector, GPU array types) enable dispatch on device characteristics.\n\nFields\n\nm::Int               - number of rows\nn::Int               - number of columns\ncolptr::ColPtrT      - column pointer array (length n+1)\nrowval::RowValT      - row indices of stored entries\nnzval::NzValT        - stored values\n\n\n\n\n\n","category":"type"},{"location":"api/#GenericSparseArrays.GenericSparseMatrixCSR","page":"API Reference","title":"GenericSparseArrays.GenericSparseMatrixCSR","text":"GenericSparseMatrixCSR{Tv,Ti,RowPtrT,ColValT,NzValT} <: AbstractGenericSparseMatrix{Tv,Ti}\n\nCompressed Sparse Row (CSR) matrix with generic storage vectors for row pointer, column indices, and nonzero values. Buffer types (e.g. Vector, GPU array types) enable dispatch on device characteristics.\n\nFields\n\nm::Int               - number of rows\nn::Int               - number of columns\nrowptr::RowPtrT      - row pointer array (length m+1)\ncolval::ColValT      - column indices of stored entries\nnzval::NzValT        - stored values\n\n\n\n\n\n","category":"type"},{"location":"api/#GenericSparseArrays.GenericSparseMatrixCOO","page":"API Reference","title":"GenericSparseArrays.GenericSparseMatrixCOO","text":"GenericSparseMatrixCOO{Tv,Ti,RowIndT<:AbstractVector{Ti},ColIndT<:AbstractVector{Ti},NzValT<:AbstractVector{Tv}} <: AbstractGenericSparseMatrix{Tv,Ti}\n\nCoordinate (COO) sparse matrix with generic storage vectors for row indices, column indices, and nonzero values. Buffer types (e.g. Vector, GPU array types) enable dispatch on device characteristics.\n\nFields\n\nm::Int               - number of rows\nn::Int               - number of columns\nrowind::RowIndT      - row indices of stored entries\ncolind::ColIndT      - column indices of stored entries\nnzval::NzValT        - stored values\n\n\n\n\n\n","category":"type"},{"location":"#GenericSparseArrays","page":"Home","title":"GenericSparseArrays","text":"Documentation for GenericSparseArrays.","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"GenericSparseArrays provides backend-agnostic sparse array container types whose internal storage vectors may live on different devices (CPU / accelerators). The initial implementation supplies:\n\nGenericSparseVector – sparse vector with generic index & value buffers.\nGenericSparseMatrixCSC – Compressed Sparse Column matrix with parametric column pointer, row index, and nonzero value buffers.\nGenericSparseMatrixCSR – Compressed Sparse Row matrix with parametric row pointer, column index, and nonzero value buffers.\n\nThese types mirror the Base SparseVector / SparseMatrixCSC interfaces for introspection (size, length, nonzeros, etc.) and can roundtrip convert to and from the Base representations.","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"#Basic-Usage","page":"Home","title":"Basic Usage","text":"using GenericSparseArrays, SparseArrays\n\n# Create a sparse vector\nV = sparsevec([2,5], [1.0, 3.5], 6)\ndV = GenericSparseVector(V)  # construct backend-agnostic version on the CPU\n\n@show size(dV)\n@show SparseVector(dV) == V\n\n# Create a sparse matrix\nA = sparse([1,2,1],[1,1,2],[2.0,3.0,4.0], 2, 2)\ndA = GenericSparseMatrixCSC(A)\n\n@show size(dA)\n@show SparseMatrixCSC(dA) == A","category":"section"},{"location":"#Matrix-Vector-Multiplication","page":"Home","title":"Matrix-Vector Multiplication","text":"# Create a sparse matrix\nA_sparse = sparse([1,2,1,3],[1,1,2,3],[2.0,3.0,4.0,5.0], 3, 3)\n@show A_sparse\n\n# Convert to GenericSparseMatrixCSC\nA_device = GenericSparseMatrixCSC(A_sparse)\n\n# Create a vector\nb = [1.0, 2.0, 3.0]\n\n# Matrix-vector multiplication\nc = A_device * b\n@show c\n\n# Verify result matches standard sparse matrix\n@show A_sparse * b == c","category":"section"},{"location":"#Backend-Adaptation-with-JLArrays","page":"Home","title":"Backend Adaptation with JLArrays","text":"JLArrays.jl provides a CPU fallback backend for testing and CI purposes. Here we use it to demonstrate backend adaptation with Adapt.jl.\n\nusing JLArrays\nusing Adapt: adapt\n\n# Create a sparse matrix\nA_sparse = sprand(Float64, 5, 4, 0.6)\n\n# Convert to GenericSparseMatrixCSC\nA_device = GenericSparseMatrixCSC(A_sparse)\n\n# Adapt to JLArray backend (CPU fallback for CI)\nA_jl = adapt(JLArray, A_device)\n\n# Create vector on same backend\nb = rand(Float64, 4)\nb_jl = JLArray(b)\n\n# Matrix-vector multiplication on JLArray backend\nc_jl = A_jl * b_jl\n\n# Results should match\n@show collect(c_jl) ≈ A_sparse * b","category":"section"},{"location":"#CSR-Matrix-Format","page":"Home","title":"CSR Matrix Format","text":"GenericSparseArrays.jl also supports the Compressed Sparse Row (CSR) format via the GenericSparseMatrixCSR type. It can be used similarly to the CSC format. \n\n# Create a sparse matrix\nA_sparse = sparse([1,2,1,3],[1,1,2,3],[2.0,3.0,4.0,5.0], 3, 3)\n\n# Convert to CSR format\nA_csr = GenericSparseMatrixCSR(A_sparse)\n@show size(A_csr)\n\n# Convert back to standard sparse matrix\n@show SparseMatrixCSC(A_csr) == A_sparse\n\n# Matrix-vector multiplication with CSR\nb = [1.0, 2.0, 3.0]\nc = A_csr * b\n@show c","category":"section"},{"location":"#Future-Work","page":"Home","title":"Future Work","text":"Planned extensions include COO formats, sparse-dense and sparse-sparse linear algebra kernels leveraging KernelAbstractions.jl / AcceleratedKernels.jl, and device-specific adaptations via dispatch on the internal buffer types.","category":"section"},{"location":"#See-Also","page":"Home","title":"See Also","text":"API Reference for complete function documentation","category":"section"}]
}
